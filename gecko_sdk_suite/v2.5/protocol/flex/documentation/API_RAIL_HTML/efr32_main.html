<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RAIL: EFR32</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAIL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('efr32_main.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">EFR32 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>While RAIL attempts to be chip-agnostic, certain hardware specifics can't be overlooked. Where possible, missing features will be simulated in software, but performance characteristics may vary. This section covers EFR32-specific content including hardware-specific configurations or calibrations.</p>
<h2>Clocks</h2>
<h3>High Frequency Clocks</h3>
<p>The EFR32 has a configurable clock tree with a number of different prescalars. One thing to keep in mind, however, is that the radio must always run off of an HFXO at 38.4 MHz. This means that you must switch your HFCLK source to the HFXO before calling <a class="el" href="group___general.html#ga6e8b6dc2c23b18768fbdba3240d864e8" title="Initializes RAIL. ">RAIL_Init()</a> and make sure to leave the CMU-&gt;HFPRESC set to 1 to prevent dividing down the radio clock. You are free to scale the peripheral (CMU-&gt;HFPERPRESC) or Cortex (CMU-&gt;HFCOREPRESC) clocks using their prescalars which are further down the clock tree. Keep in mind that this may introduce extra wait states when interacting with the radio and slow down some operations.</p>
<h3>Low Frequency Clocks</h3>
<p>RAIL can use a low frequency clock on the EFR32 to synchronize its time base across EM2 sleep. This only happens if you call <a class="el" href="group___system___timing.html#gaa1e47ba12298e3af21680d6d6fe7cfd3">RAIL_ConfigSleep</a> with <a class="el" href="group___system___timing.html#gga5156120c7894fefec8ab74bdb6a827e8ab858c29bea0a5f24d47ec3b38225893b">RAIL_SleepConfig_t::RAIL_SLEEP_CONFIG_TIMERSYNC_ENABLED</a>. On the EFR32xG1 and EFR32xG12 this uses the RTCC's clock which is the LFE clock with a possible additional prescalar. The slower the clock source here the longer it will take to synchronize since the process requires several ticks of the RTCC clock. On the EFR32xG13 and EFR32xG14 there is a separate timer to help with this synchronization, but either the LFXO or LFRCO are still used. When calling <a class="el" href="group___system___timing.html#gaa1e47ba12298e3af21680d6d6fe7cfd3">RAIL_ConfigSleep()</a> the code will first try to setup the timer with the LFXO if it's started, then fallback to the LFRCO, and finally assert if no LF clocks are running.</p>
<h2>Packet Buffer Restrictions</h2>
<p>The RAIL library for the EFR32 optionally allocates an internal buffer to store receive data contiguously. Other than being byte-aligned, the buffer has no further alignment restrictions. The buffer is set to 512 bytes at build time by default, but can be changed by calling <a class="el" href="group___data___management.html#ga4cf7a074232bafeb00bc8ebd10a28dba">RAIL_SetRxFifo</a>, for example in an implementation of <a class="el" href="group___data___management.html#gac4b90d064ca53c93a16f95dcdaba87b3">RAILCb_SetupRxFifo</a>. The receive FIFO's size must be a power of 2 between 128 and 4096 for hardware compatibility. This choice limits the maximum size of receive packets in packet mode and determines the size of the receive FIFO in FIFO mode. Since each receive packet has 6 bytes of overhead, you can only receive up to one 506 byte packet without overriding the RX FIFO or switching to FIFO mode. In FIFO mode, you must read out packet data as you approach this limit and store it off to construct the full packet later. Note that the 6 byte overhead may increase or decrease in future releases as the functionality is changed though large jumps are not expected in either direction.</p>
<p>The transmit FIFO must be set at runtime with <a class="el" href="group___data___management.html#gaba67c4561ebc027318a70903c9e9daf2">RAIL_SetTxFifo()</a>. The transmit FIFO must also be byte-aligned, with no further restrictions. Its size has the same restrictions as the receive FIFO. The size must be a power of 2 from 64 to 4096 for hardware compatibility. Note that there is no difference between packet and FIFO mode on the transmit side. A packet may either be loaded all at once or in pieces using the <a class="el" href="group___data___management.html#ga07f5f915afee301566bcef99cfae00c2">RAIL_WriteTxFifo()</a> function. You may also use the <a class="el" href="group___data___management.html#ga1c78ceb2b403a74e597248d27aa44bba">RAIL_SetTxFifoThreshold()</a> function and the <a class="el" href="group___events.html#ga86afb7a7422963a4edd5e0db0228b09f">RAIL_EVENT_TX_FIFO_ALMOST_EMPTY</a> event to load data as there is space available in the FIFO during transmission.</p>
<h2>Data Reception Sources</h2>
<p>When receiving data, you can configure hardware to provide data from three different hardware sources.</p>
<p>First, you can configure the hardware to provide a packet of information. This configuration uses the built-in demodulator and frame controller. Use <a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9a51031cf6cfe1090806bd80081a48febd">RAIL_RxDataSource_t::RX_PACKET_DATA</a> to enable this receive source.</p>
<p>Second, you can configure hardware to provide data directly from the demodulator. In this mode, hardware demodulation is used, but the user is responsible for implementing frame controller functionality. In other words, preamble detection, sync word detection, CRC validation, and so on must be performed in software by the application. All data returned is represented as 8-bit 2's-compliment values. Use <a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9a3680d24c321ca9595f80f4062284de82">RAIL_RxDataSource_t::RX_DEMOD_DATA</a> to enable the receive source.</p>
<p>Third, you can configure hardware to provide data directly from the I and Q ADCs. In this mode, the user is responsible for implementing demodulator and frame controller functionality. The receive signal hardware has a 19-bit dynamic range. The user can select whether to return the upper 16 bits of the 19-bit value (<a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9adfa3e1b96a7fed050c2e5a94c84e5e7a">RAIL_RxDataSource_t::RX_IQDATA_FILTMSB</a>) or the lower 16 bits (<a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9ad7221f15ed90ababb5aea07e8492a1b1">RAIL_RxDataSource_t::RX_IQDATA_FILTLSB</a>). All data returned is represented as 16-bit 2s-compliment values. The I and Q values are put into the buffer in an alternating fashion where the first 16-bit value is the first I ADC value and the second 16-bit value is the first Q ADC value, and so on.</p>
<h2>Interrupt Vectors</h2>
<p>The RAIL library for EFR32 implements all of the interrupt vectors for radio peripherals, which is required for the RAIL library to function correctly. RAIL does not, however, set the priorities of these interrupt vectors. That must be handled by your application using the CMSIS NVIC_SetPriority() API or direct manipulation of the NVIC. Below is the full list of interrupts used by the radio. You <b>must</b> run them all at the same priority which is what all Silicon Labs RAIL applications do by default. You are free to choose what that priority is based on the requirements of your application (e.g., putting them below FreeRTOS OS atomic for access to OS functions in RAIL callbacks). Keep in mind that putting the radio interrupts at too low a priority can cause missed packets and other radio performance issues. A restriction on EFR32xG12 and newer is that you must not disable radio interrupts for longer than a quarter of the RAIL timebase (2^32/4 microseconds or 18 minutes) to ensure proper timekeeping. See <a class="el" href="group___e_f_r32x_g1x___interrupts.html">EFR32xG1x_Interrupts</a> or follow the links below for more information.</p>
<div class="fragment"><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga5136e4598377244337749247a93f0432">FRC_PRI_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga0c7a131a40ec0f4f4aedbdad5f15b399">FRC_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga0c462dd15369865c11875a6146538578">MODEM_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#gadc2b9acaacd718dcd2e78deacd2b015b">RAC_SEQ_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga20868c2069184ad702beabab4606af73">RAC_RSM_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#gaf0715f354743cd91d25299840842a730">BUFC_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga1381fd3f099f38e273bb091a176fe073">AGC_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#gaae7189e0f1296a5c53a26a45a2d762ad">PROTIMER_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga7e71cb986f574513f202d02f97a3eb63">SYNTH_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga289a52d34c2bbc45e59e4b4c3dc3b958">RFSENSE_IRQHandler</a></div></div><!-- fragment --><h1>Chip-specific Initialization</h1>
<h2>EFR32 Hardware Initialization</h2>
<p>EFR32 includes EMLIB and EMDRV to create a basic HAL layer. A lot of this initialization code is completely up to you, but there are a couple of requirements when building a RAIL app. Specifically, the radio will only work if you are running off a high-precision crystal oscillator. Since some APIs will assume this is running, make sure to initialize and switch to the crystal before calling any radio APIs.</p>
<p>For the Wireless Starter Kit (WSTK), you can use the crystal configuration in the HAL configuration header file for your specific kit. Example code for this is shown below. If you have a custom hardware layout, you may want to create your own HFXOInit structure to account for things such as your specific CTUNE value.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;bsp.h&quot;</span> <span class="comment">// Contains WSTK versions of the HFXO init structure</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> efrStartup(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  CMU_HFXOInit_TypeDef hfxoInit = CMU_HFXOINIT_WSTK_DEFAULT;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize the HFXO using the settings from the WSTK bspconfig.h</span></div><div class="line">  <span class="comment">// Note: This configures things like the capacitive tuning CTUNE variable</span></div><div class="line">  <span class="comment">//   which can vary based on your hardware design.</span></div><div class="line">  CMU_HFXOInit(&amp;hfxoInit);</div><div class="line"></div><div class="line">  <span class="comment">// Switch HFCLK to HFXO and disable HFRCO</span></div><div class="line">  CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO);</div><div class="line">  CMU_OscillatorEnable(cmuOsc_HFRCO, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><h2>Radio-specific Initialization</h2>
<p>Currently, <a class="el" href="group___p_a.html#ga457d647ef941d0074c5b0570c252a4dd">RAIL_ConfigTxPower()</a> and <a class="el" href="group___p_t_i.html#gabf0efa0e39d0b3e91aff1da870a9b71a">RAIL_ConfigPti()</a> initialization functions depend on the board configuration and must be manually called at startup. You <b>MUST</b> initialize the power amplifier (PA) to transmit. You may initialize the packet trace interface (PTI) for use in debugging.</p>
<h3>Power Amplifier (PA) Initialization</h3>
<p><a class="el" href="group___p_a___e_f_r32.html#ggaee32825f3105d9af8ef2d9892a6950cba2516560d659c6560e761f5611b6e0dba">High Power 2.4GHz PA</a>, <a class="el" href="group___p_a___e_f_r32.html#ggaee32825f3105d9af8ef2d9892a6950cba4389b6e0c999726991d09d66e4a0c57f">Low Power 2.4GHz PA</a>, and <a class="el" href="group___p_a___e_f_r32.html#ggaee32825f3105d9af8ef2d9892a6950cba6b59de3cb3ac1f64a9eb7e56a311a38d">Sub GHz PA</a> PAs are available for the EFR32xG1 family of chips. The specific set of PAs you have available and the supported power levels for those PAs are determined by your part number. See the appropriate data sheet for more details.</p>
<p>Each PA supports a raw power level value of type <a class="el" href="group___p_a___e_f_r32.html#ga37838bfd8f434aade272985edd3b745d">RAIL_TxPowerLevel_t</a> where a numerically smaller number causes less power to be output from the chip than a higher number. Keep in mind that these values may be capped at the upper and lower ends and do not necessarily map linearly to output power in dBm. To map these values to and from dBm values, the RAIL library uses the <a class="el" href="group___p_a.html#ga45369bac87a05c50ca39d31a0dd78ce2">RAIL_ConvertRawToDbm()</a> and <a class="el" href="group___p_a.html#gacdd8ac5181abb15e4f6409a85023c4bf">RAIL_ConvertDbmToRaw()</a> APIs. By default, these use whatever piecewise linear power curves were passed into RAIL_InitTxPowerCurves() to do the conversion. On Silicon Labs boards, these curves are included with the board header files. For custom boards, this must be measured using test equipment to take into account the differences in the RF path that may exist. In addition, for even more custom use cases, the conversion functions can be strongly defined in the customer application and provide whatever type of mapping is found to be most effective. Below is an example of using the standard APIs to initialize all PAs on a dual band chip and switch to the 2.4 GHz high-power PA.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail_8h.html">rail.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail__chip__specific_8h.html">rail_chip_specific.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;plugin/pa-conversion/pa_conversion_efr32.h&quot;</span></div><div class="line"></div><div class="line">RAIL_DECLARE_TX_POWER_VBAT_CURVES(piecewiseSegments, curvesSg, curves24Hp, curves24Lp);</div><div class="line"></div><div class="line"><span class="comment">// Must be called with a valid RAIL_Handle_t returned by RAIL_Init()</span></div><div class="line"><span class="keywordtype">void</span> initPa(<a class="code" href="group___general.html#gade1c256898a301054e34aeee015a3582">RAIL_Handle_t</a> myRailHandle)</div><div class="line">{</div><div class="line">  <span class="comment">// Initialize the RAIL Tx power curves for all PAs on this chip</span></div><div class="line">  RAIL_TxPowerCurvesConfig_t txPowerCurvesConfig = {</div><div class="line">    curves24Hp,</div><div class="line">    curvesSg,</div><div class="line">    curves24Lp,</div><div class="line">    piecewiseSegments</div><div class="line">  };</div><div class="line">  <span class="keywordflow">if</span> (RAIL_InitTxPowerCurves(&amp;txPowerCurvesConfig) != <a class="code" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a9d08f2cf4b5a12507982c72d5b896a02">RAIL_STATUS_NO_ERROR</a>) {</div><div class="line">    <span class="comment">// Could not initialize transmit power curves so something is configured</span></div><div class="line">    <span class="comment">// wrong. Please fix and rebuild.</span></div><div class="line">    <span class="keywordflow">while</span>(1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Switch to the 2.4GHz HP PA powered off the 1.8V DCDC connection</span></div><div class="line">  <a class="code" href="struct_r_a_i_l___tx_power_config__t.html">RAIL_TxPowerConfig_t</a> railTxPowerConfig = {</div><div class="line">    <a class="code" href="group___p_a___e_f_r32.html#ggaee32825f3105d9af8ef2d9892a6950cba2516560d659c6560e761f5611b6e0dba">RAIL_TX_POWER_MODE_2P4_HP</a>, <span class="comment">// 2.4GHz HP Power Amplifier mode</span></div><div class="line">    1800,                      <span class="comment">// 1.8V vPA voltage for DCDC connection</span></div><div class="line">    10                         <span class="comment">// Desired ramp time in us</span></div><div class="line">  };</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group___p_a.html#ga457d647ef941d0074c5b0570c252a4dd">RAIL_ConfigTxPower</a>(myRailHandle, &amp;railTxPowerConfig)</div><div class="line">      != <a class="code" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a9d08f2cf4b5a12507982c72d5b896a02">RAIL_STATUS_NO_ERROR</a>) {</div><div class="line">    <span class="comment">// Error: The requested PA could not be selected. Fix your configuration</span></div><div class="line">    <span class="comment">// and try again.</span></div><div class="line">    <span class="keywordflow">while</span>(1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Set the output power to the maximum supported by this chip</span></div><div class="line">  <a class="code" href="group___p_a.html#ga2e14fc78b4debe690a70888d5a2850c1">RAIL_SetTxPower</a>(myRailHandle, 255);</div><div class="line">}</div></div><!-- fragment --><h3>Packet Trace Interface (PTI) Initialization</h3>
<p>Packet trace on the EFR32 provides a mechanism for viewing transmitted and received radio packets for network sniffing or debugging. It can also be captured by a WSTK and sent to Simplicity Studio for viewing data in its Network Analyzer tool.</p>
<p>To use this functionality, configure the pins to use for this output and, optionally, how to format data. Note that the WSTK <em>requires</em> the following output format: </p><pre class="fragment">Mode: 8 bit UART mode
Baudrate: 1.6Mbps
Framing Signal: Enabled
</pre><p>Introducing changes is currently unsupported by the WSTK. Other output formats are currently unsupported.</p>
<p>To choose the pins, look in the applicable data sheet and select a valid route location for the FRC_DOUT and FRC_DFRAME signals. These map to PTI.DATA and PTI.FRAME on the WSTK respectively. Once you've found pins that work for your hardware, configure the RouteLocation, port, and pin fields in the PTI initialization structure. When using the WSTK for example, initialize as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail_8h.html">rail.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail__chip__specific_8h.html">rail_chip_specific.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> initPti(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <a class="code" href="struct_r_a_i_l___pti_config__t.html">RAIL_PtiConfig_t</a> ptiConfig =   {</div><div class="line">    <a class="code" href="group___p_t_i___e_f_r32.html#gga0076e83c728b4a4416535d3a844dc0e2ad234c120e1441a2620ea81ec8ba86ecf">RAIL_PTI_MODE_UART</a>,     <span class="comment">// Only supported output mode for the WSTK</span></div><div class="line">    1600000,                <span class="comment">// Choose 1.6 Mbps for the WSTK</span></div><div class="line">    6,                      <span class="comment">// WSTK uses location 6 for DOUT</span></div><div class="line">    gpioPortB,              <span class="comment">// FRC_DOUT#6 is PB12</span></div><div class="line">    12,                     <span class="comment">// FRC_DOUT#6 is PB12</span></div><div class="line">    6,                      <span class="comment">// UNUSED IN UART MODE</span></div><div class="line">    gpioPortB,              <span class="comment">// UNUSED IN UART MODE</span></div><div class="line">    11,                     <span class="comment">// UNUSED IN UART MODE</span></div><div class="line">    6,                      <span class="comment">// WSTK uses location 6 for DFRAME</span></div><div class="line">    gpioPortB,              <span class="comment">// FRC_DOUT#6 is PB13</span></div><div class="line">    13,                     <span class="comment">// FRC_DOUT#6 is PB13</span></div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize the Packet Trace Interface (PTI) for the EFR32</span></div><div class="line">  <a class="code" href="group___p_t_i.html#gabf0efa0e39d0b3e91aff1da870a9b71a">RAIL_ConfigPti</a>(<a class="code" href="group___multiprotocol___e_f_r32.html#ga9cc0246bb308ae8311cf0e746c42372e">RAIL_EFR32_HANDLE</a>, &amp;ptiConfig);</div><div class="line"></div><div class="line">  <span class="comment">// Enable Packet Trace (PTI)</span></div><div class="line">  <a class="code" href="group___p_t_i.html#ga75353cc601b04acf7bf55c9d8c53ba91">RAIL_EnablePti</a>(<a class="code" href="group___multiprotocol___e_f_r32.html#ga9cc0246bb308ae8311cf0e746c42372e">RAIL_EFR32_HANDLE</a>, <span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><h3>Other Radio GPIO Functions</h3>
<p>Various useful signals related to the radio can be output on a GPIO using the Peripheral Reflex System (PRS). PRS is an advanced system where you can route signals to channels and then output those channels to a number of configurable locations. For more information, see the PRS chapter in the reference manual.</p>
<p>A list of some of the most interesting PRS signals related to the radio is shown below along with how to enable them in the PRS. The definition for these signals for a given chip can be found in the release at <code>platform/Device/SiliconLabs/&lt;chipFamily&gt;/Include/&lt;chipFamily&gt;_prs_signals.h</code> where <code>&lt;chipFamily&gt;</code> would be the beginning of the part number (EFR32MG12P for example).</p>
<table class="doxtable">
<tr>
<th align="left">Signal </th><th align="left">Summary  </th></tr>
<tr>
<td align="left">PRS_RAC_ACTIVE </td><td align="left">Radio enabled </td></tr>
<tr>
<td align="left">PRS_RAC_TX </td><td align="left">Transmit mode enabled </td></tr>
<tr>
<td align="left">PRS_RAC_RX </td><td align="left">Receive mode enabled </td></tr>
<tr>
<td align="left">PRS_RAC_LNAEN </td><td align="left">LNA enabled for Rx </td></tr>
<tr>
<td align="left">PRS_RAC_PAEN </td><td align="left">PA enabled for Tx </td></tr>
<tr>
<td align="left">PRS_MODEM_FRAMEDET </td><td align="left">Frame detected </td></tr>
<tr>
<td align="left">PRS_MODEM_PREDET </td><td align="left">Preamble detected </td></tr>
<tr>
<td align="left">PRS_MODEM_TIMDET </td><td align="left">Timing detected </td></tr>
<tr>
<td align="left">PRS_MODEM_FRAMESENT </td><td align="left">Frame sent </td></tr>
<tr>
<td align="left">PRS_MODEM_SYNCSENT </td><td align="left">Syncword sent </td></tr>
<tr>
<td align="left">PRS_MODEM_PRESENT </td><td align="left">Preamble sent </td></tr>
</table>
<p>The example below shows how to configure a PRS channel to output RAC_RX on a GPIO. In this example, the WSTK is used with the BRD4153A radio board. The code below will put RAC_RX on PRS Channel 0 and output PRS Channel 0 on pin PC10 which is wired to WSTK_P12 and EXP_HEADER15 on the WSTK.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;em_cmu.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;em_prs.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;em_gpio.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;em_device.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> enableDebugGpios(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// Turn on the PRS and GPIO clocks to access their registers.</span></div><div class="line">  CMU_ClockEnable(cmuClock_PRS, <span class="keyword">true</span>);</div><div class="line">  CMU_ClockEnable(cmuClock_GPIO, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Configure PC10 as an output.</span></div><div class="line">  GPIO_PinModeSet(gpioPortC, 10, gpioModePushPull, 0);</div><div class="line"></div><div class="line">  <span class="comment">// Configure PRS Channel 0 to output RAC_RX.</span></div><div class="line">  PRS_SourceSignalSet(0,</div><div class="line">                      ((PRS_RAC_RX &amp; _PRS_CH_CTRL_SOURCESEL_MASK)</div><div class="line">                       &gt;&gt; _PRS_CH_CTRL_SOURCESEL_SHIFT),</div><div class="line">                      ((PRS_RAC_RX &amp; _PRS_CH_CTRL_SIGSEL_MASK)</div><div class="line">                       &gt;&gt; _PRS_CH_CTRL_SIGSEL_SHIFT),</div><div class="line">                      prsEdgeOff);</div><div class="line"></div><div class="line">  <span class="comment">// Configure PRS Channel 0 to use output location 12 (PC10 - see data sheet).</span></div><div class="line">  PRS-&gt;ROUTELOC0 &amp;= ~_PRS_ROUTELOC0_CH0LOC_MASK;</div><div class="line">  PRS-&gt;ROUTELOC0 |= PRS_ROUTELOC0_CH0LOC_LOC12;</div><div class="line"></div><div class="line">  <span class="comment">// Enable PRS Channel 0.</span></div><div class="line">  PRS-&gt;ROUTEPEN |= PRS_ROUTEPEN_CH0PEN;</div><div class="line">}</div></div><!-- fragment --><h2>Required Dependencies</h2>
<p>Most of the RAIL library is self-contained, however, there are some dependencies on external functions, such as functions from the C standard library, EMLIB, and CMSIS. Below is a complete list of these dependencies. Note that changing the implementation of any of these functions while maintaining their functionality could still impact RAIL operation.</p>
<table class="doxtable">
<tr>
<th>Group </th><th>Functions  </th></tr>
<tr>
<td>CMSIS </td><td><code>SystemHFXOClockGet()</code><br />
<code>SystemHFClockGet()</code><br />
<code>SystemLFRCOClockGet()</code><br />
<code>SystemLFXOClockGet()</code><br />
<code>SystemULFRCOClockGet()</code> </td></tr>
<tr>
<td>EMLIB (em_cmu) </td><td><code>CMU_ClockEnable</code><br />
<code>CMU_ClockSelectGet</code><br />
<code>CMU_ClockSelectSet</code><br />
<code>CMU_OscillatorEnable</code><br />
 </td></tr>
<tr>
<td>EMLIB (em_gpio) </td><td><code>GPIO_PinModeSet()</code> </td></tr>
<tr>
<td>EMLIB (em_system) </td><td><code>SYSTEM_ChipRevisionGet()</code> </td></tr>
<tr>
<td>EMLIB (em_core) </td><td><code>CORE_EnterCritical()</code><br />
<code>CORE_ExitCritical()</code><br />
<code>CORE_EnterAtomic()</code><br />
<code>CORE_ExitAtomic()</code> </td></tr>
<tr>
<td>EMLIB (em_emu) </td><td><code>EMU_DCDCLnRcoBandSet()</code> </td></tr>
<tr>
<td>stdlib </td><td><code>memcpy()</code><br />
<code>memset()</code> </td></tr>
</table>
<h2>Peripherals Consumed by RAIL</h2>
<p>Certain functionality in RAIL requires some of the chip's peripherals. The specifics of these requirements are enumerated below.</p>
<h3>RAIL Timer Synchronization</h3>
<p>If you call <a class="el" href="group___system___timing.html#gaa1e47ba12298e3af21680d6d6fe7cfd3">RAIL_ConfigSleep</a> with <a class="el" href="group___system___timing.html#gga5156120c7894fefec8ab74bdb6a827e8ab858c29bea0a5f24d47ec3b38225893b">RAIL_SleepConfig_t::RAIL_SLEEP_CONFIG_TIMERSYNC_ENABLED</a> to keep the clock synchronized across sleep RAIL must use the PRS and RTCC.</p><ul>
<li>On all platforms PRS channel 7 is used to perform the synchronization. This channel is only initialized one time when calling the <a class="el" href="group___system___timing.html#gaa1e47ba12298e3af21680d6d6fe7cfd3">RAIL_ConfigSleep</a> function so you must not change it after that or the synchronization may fail.</li>
<li>On the EFR32xG1 and EFR32xG12 platforms the timer synchronization also uses RTCC channel 0. This channel should not be used by the application after a call to <a class="el" href="group___system___timing.html#ga7859226adeb8f7f47a1a9230fb56e6ad">RAIL_Sleep</a> and before the corresponding <a class="el" href="group___system___timing.html#ga7ee28a109ec80256880b21e2b67c51ff">RAIL_Wake</a> call. The application is also responsible for enabling this top level interrupt if they want it to serve as a wake source and implementing an interrupt handler that clears the RTCC_IFC_CC0 flag in the RTCC-&gt;IF register any time it is pended to prevent the chip from getting stuck in the handler. RAIL does not need to be tied into the interrupt handler in any other way.</li>
</ul>
<h2>Entropy Generation</h2>
<p>EFR32 supports true entropy collection using the radio. It is able to collect 1 bit per radio clock cycle while in receive mode. This means that the receiver must be enabled when collecting entropy. If you attempt to transmit or otherwise delay entry into receive, data collection will take longer. You can still receive packets while collecting entropy. This means that requesting random numbers longer than the length of your preamble and sync word may trigger a packet reception. This may be fixed in a future revision but for now it ensures a proper packet reception during a random data collection.</p>
<p>Due to the nature of random data collection, either the number of bytes or zero is returned after the full amount requested. Zero is returned if the radio is uninitialized and cannot be enabled for collection.</p>
<h2>RAIL Timebase</h2>
<p>EFR32 uses a dedicated radio timer to create the RAIL timebase and perform scheduled transmit and receive operations. This timer ticks at roughly every 2 us on the EFR32xG1 platform and 0.5 us on the EFR32xG12 and newer. The exact tick value depends on the high-frequency crystal in use so there may be a small rounding error. All internal APIs account for this error, so over long periods of time it is generally unnoticeable. Note that RAIL uses the hardware tick rate to create a 1 us time base that is exposed to the user. This is all that should matter for most users and the information here is included to explain the underlying implementation.</p>
<h2>Radio Calibration</h2>
<p>EFR32 supports image rejection (IR) calibration and VCO temperature calibration. You may choose to enable one or both depending on your use case. Using both is recommended for optimal performance of the radio.</p>
<ul>
<li>Image Rejection Calibration (IRCAL)<ul>
<li>This calibration should be run each time your PHY configuration changes. It is based on the modulation scheme, frequency band, and other radio settings. RAIL will request this by calling <a class="el" href="struct_r_a_i_l___config__t.html#ac306471283408d4d47ffca784681c740">RAIL_Config_t::eventsCallback</a> with the <a class="el" href="group___events.html#gae37e72673345ce4cd4e4c3ba8abe014a">RAIL_EVENT_CAL_NEEDED</a> bit set and the <a class="el" href="group___calibration___e_f_r32.html#ga97381526c792e093e656130c9a11f12d">RAIL_CAL_ONETIME_IRCAL</a> bit set in <a class="el" href="group___calibration.html#ga1d04d99f4c0e0e82717019fb7735d0b0">RAIL_GetPendingCal()</a>.</li>
<li>Using a proper value for this will improve sensitivity by several dBm, so it's highly recommended.</li>
<li>It can take on the order of 700 ms to complete this calibration. You may want to save off a known good value for this calibration and load it each time you switch PHYs to save time.</li>
<li>This calibration should be initialized before calling <a class="el" href="group___radio___configuration.html#ga19be74a219d6d9271db022b37639c203">RAIL_ConfigChannels()</a> to ensure that it is properly configured by the time the first channel is set up. The initialization involves enabling the algorithm and passing in parameters to configure the algorithm for the specific PHY generated by the EFR32 Radio Configurator.</li>
<li>You cannot use the radio while this calibration is being performed or you may generate an incorrect calibration. Application code should ensure that the radio remains in the idle state during this calibration.</li>
<li>This calibration is only meaningful for Zigbee, BLE, and sub GHz radio configurations. For all others you should still enable the calibration but the algorithm will apply a safe, default, calibration value.</li>
</ul>
</li>
<li>VCO Temperature Calibration (VCO_TEMPCAL)<ul>
<li>When staying in receive for a very long time and the temperature changes causing the radio to drift off-frequency, RAIL will request this calibration via <a class="el" href="struct_r_a_i_l___config__t.html#ac306471283408d4d47ffca784681c740">RAIL_Config_t::eventsCallback</a> with the <a class="el" href="group___events.html#gae37e72673345ce4cd4e4c3ba8abe014a">RAIL_EVENT_CAL_NEEDED</a> bit set and the <a class="el" href="group___calibration___e_f_r32.html#ga28feea6fbfddfe14e4ba5290b301081d">RAIL_CAL_TEMP_VCO</a> bit set in RAIL_CalPendingGet().</li>
<li>This calibration is automatically run every time receive is entered. If the application, by its nature, frequently re-enters receive mode, this calibration may not need to be enabled.</li>
<li>On EFR, the application will get this event when the absolute temperature crosses 0C degrees as well as when the temperature delta from the last calibration increases or decreases by 70C.</li>
<li>It is always recommended to enable and handle this calibration since it doesn't add much overhead and is much safer.</li>
</ul>
</li>
</ul>
<h2>State Transition Timing</h2>
<p>EFR32 allows automatic transitions from receive to transmit to precisely time transmitted packets after packet reception. During this process, internal calculations are performed which require the received packet's duration, from sync word to end of CRC, to be less than 32 ms. If received packets in a given protocol have an on-air time greater than 32 ms, the automatic transition from receive to transmit may not be used with that protocol because of incorrect timing of that transition.</p>
<h2>Radio State Verification</h2>
<p>RAIL includes a radio state verification feature capable of verifying radio register contents. There are multiple ways of configuring and running the verification process. All radio state verification should occur when the radio is idle. If not idle, the number of radio registers different from their reference values varies at any given time.</p>
<h3>Default vs. Custom Radio Config</h3>
<p>When verification occurs, a reference value is compared with a radio register's contents. The reference value is provided through one of two ways.</p>
<p>The radio configuration (originally passed into <a class="el" href="group___radio___configuration.html#ga19be74a219d6d9271db022b37639c203">RAIL_ConfigChannels()</a>) is used as a reference with which to compare radio register values. When the default radio configuration is used for verification, only those addresses flagged as being verifiable by the radio configurator will be checked. Bit 27 of an encoded address indicates whether that address is verifiable or not. For example, encoded address 0x08020004 is flagged as being verifiable and will be verified when <a class="el" href="group___diagnostic.html#ga13fefc769f8582db50a71b4542b92371">RAIL_Verify()</a> is called, but the encoded address 0x00020008 will not be verified.</p>
<p>A custom radio configuration can be provided to the verification API (passed into <a class="el" href="group___diagnostic.html#gacecb36b7e471ea72432fd9433a46ab68">RAIL_ConfigVerification()</a>). When a custom radio configuration is provided, all addresses in the provided radio configuration will be checked, regardless of whether or not their encoded addresses are flagged as being verifiable.</p>
<h3>Approval Callback</h3>
<p>When verification occurs, no register value differences are allowed unless an application-level approval callback is defined.</p>
<p>Without an approval callback, any difference will be flagged as data corruption, with <a class="el" href="group___diagnostic.html#ga13fefc769f8582db50a71b4542b92371">RAIL_Verify()</a> returning a status of <a class="el" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a3ddab27ab553255df061547afe90ebee">RAIL_STATUS_INVALID_STATE</a>.</p>
<p>With an approval callback, the application can scrutinize all differences and deem them acceptable or not. By providing an approval callback, individual register fields, instead of the entire register contents, can be compared against reference values at the application level.</p>
<h3>Restarting</h3>
<p>Verification can be restarted if necessary.</p>
<p>When running verification from the beginning to completion (by specifying a sufficiently long test duration or by specifying a duration of <a class="el" href="group___diagnostic.html#gab0af6ab85aa8f9a4e3a64fbb3c317521">RAIL_VERIFY_DURATION_MAX</a>), the verification process is indifferent to the restart parameter.</p>
<p>When running verification for a duration that does not permit verification to run to completion, the <a class="el" href="group___diagnostic.html#ga13fefc769f8582db50a71b4542b92371">RAIL_Verify()</a> function will return with a status of <a class="el" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a4bea7d8dd1a2b6a8b849cef8336ffc88">RAIL_STATUS_SUSPENDED</a>. This indicates test success for those values already verified, but sufficient time was not permitted to verify all values. In this scenario, the initial run of <a class="el" href="group___diagnostic.html#ga13fefc769f8582db50a71b4542b92371">RAIL_Verify()</a> is indifferent to the value of the restart input, but subsequent runs of <a class="el" href="group___diagnostic.html#ga13fefc769f8582db50a71b4542b92371">RAIL_Verify()</a> should set the restart input to false so that verification will resume where it left off on the previous call. To record where a previous verification left off, the <a class="el" href="struct_r_a_i_l___verify_config__t.html">RAIL_VerifyConfig_t</a> structure must be declared by the application and provided to RAIL. These structure contents should only be altered by RAIL.</p>
<h3>Configuration and Running Options</h3>
<p>With the ability to specify default radio configuration vs. custom radio configuration, approval callback vs. no approval callback, and run to completion vs. run for a specific time, there are multiple ways in which to run RAIL's radio state verification feature. The example below shows running verification in each of these modes.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail_8h.html">rail.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail__types_8h.html">rail_types.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;rail_config.h&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="struct_r_a_i_l___verify_config__t.html">RAIL_VerifyConfig_t</a> configVerify;</div><div class="line"></div><div class="line"><span class="keyword">const</span> uint32_t customRadioConfig[] = {</div><div class="line">  0x00010048UL, 0x00000000UL,</div><div class="line">  0x000400A0UL, 0x00004CFFUL,</div><div class="line">     <span class="comment">/* 00A4 */</span> 0x00000000UL,</div><div class="line">     <span class="comment">/* 00A8 */</span> 0x00004DFFUL,</div><div class="line">     <span class="comment">/* 00AC */</span> 0x00000000UL,</div><div class="line">  0x00012000UL, 0x00000744UL,</div><div class="line">  ...</div><div class="line">  0xFFFFFFFFUL,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> RAILCb_VerificationApproval(uint32_t address,</div><div class="line">                                 uint32_t expectedValue,</div><div class="line">                                 uint32_t actualValue)</div><div class="line">{</div><div class="line">  responsePrint(<span class="stringliteral">&quot;verifyRadioCb&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;address:0x%08x,expectedValue:0x%08x,actualValue:0x%08x&quot;</span>,</div><div class="line">                address, expectedValue, actualValue);</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span> OR <span class="keyword">false</span>; <span class="comment">// true = change approved; false = change unapproved</span></div><div class="line">}</div><div class="line"></div><div class="line">main ()</div><div class="line">{</div><div class="line">  <a class="code" href="group___general.html#gae0d330e2daabbf1988161b4bba1ddef3">RAIL_Status_t</a> result;</div><div class="line">  ...</div><div class="line">  <span class="comment">// Initialize the radio.</span></div><div class="line">  railHandle = <a class="code" href="group___general.html#ga6e8b6dc2c23b18768fbdba3240d864e8">RAIL_Init</a>(..., ...);</div><div class="line">  ...</div><div class="line">  <span class="comment">// Associate a radio config with this RAIL handle.</span></div><div class="line">  <a class="code" href="group___radio___configuration.html#ga19be74a219d6d9271db022b37639c203">RAIL_ConfigChannels</a>(railHandle, channelConfigs[0], ...);</div><div class="line">  ...</div><div class="line">  <span class="comment">// Idle the radio before verifying registers.</span></div><div class="line">  <a class="code" href="group___state___transitions.html#ga5859aec2a23b30d13a3a436a551aea05">RAIL_Idle</a>(railHandle, <a class="code" href="group___state___transitions.html#ggaa259ec596f750bc0a13a7aa42a6e7e27a572ff605d5403bd3f78663775ffbc5d1">RAIL_IDLE</a>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  uint8_t verifyConfigOption = 1; <span class="comment">// 1,2,3,4</span></div><div class="line">  uint8_t verifyRunOption    = 1; <span class="comment">// 1,2</span></div><div class="line"></div><div class="line">  <span class="comment">// Configure the radio state verification in one of 4 ways:</span></div><div class="line">  <span class="keywordflow">if</span> (1 == verifyConfigOption) {</div><div class="line">    <span class="comment">// Config Option 1: Use default radio config with no approval callback.</span></div><div class="line">    <a class="code" href="group___diagnostic.html#gacecb36b7e471ea72432fd9433a46ab68">RAIL_ConfigVerification</a>(railHandle,</div><div class="line">                            &amp;configVerify,</div><div class="line">                            NULL,   <span class="comment">// use channelConfigs[0] for verification</span></div><div class="line">                            NULL);</div><div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (2 == verifyConfigOption) {</div><div class="line">    <span class="comment">// Config Option 2: Use default radio config with approval callback.</span></div><div class="line">    <a class="code" href="group___diagnostic.html#gacecb36b7e471ea72432fd9433a46ab68">RAIL_ConfigVerification</a>(railHandle,</div><div class="line">                            &amp;configVerify,</div><div class="line">                            NULL,   <span class="comment">// use channelConfigs[0] for verification</span></div><div class="line">                            RAILCb_VerificationApproval);</div><div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (3 == verifyConfigOption) {</div><div class="line">    <span class="comment">// Config Option 3: Use custom radio config with no approval callback.</span></div><div class="line">    <a class="code" href="group___diagnostic.html#gacecb36b7e471ea72432fd9433a46ab68">RAIL_ConfigVerification</a>(railHandle,</div><div class="line">                            &amp;configVerify,</div><div class="line">                            &amp;customRadioConfig[0],</div><div class="line">                            NULL);</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">// Config Option 4: Use custom radio config with approval callback.</span></div><div class="line">    <a class="code" href="group___diagnostic.html#gacecb36b7e471ea72432fd9433a46ab68">RAIL_ConfigVerification</a>(railHandle,</div><div class="line">                            &amp;configVerify,</div><div class="line">                            &amp;customRadioConfig[0],</div><div class="line">                            RAILCb_VerificationApproval);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Run the radio state verification in one of 2 ways:</span></div><div class="line">  <span class="keywordflow">if</span> (1 == verifyRunOption) {</div><div class="line">    <span class="comment">// Run Option 1: Run verification once to completion.</span></div><div class="line">    result = <a class="code" href="group___diagnostic.html#ga13fefc769f8582db50a71b4542b92371">RAIL_Verify</a>(railHandle,</div><div class="line">                         &amp;configVerify,</div><div class="line">                         <a class="code" href="group___diagnostic.html#gab0af6ab85aa8f9a4e3a64fbb3c317521">RAIL_VERIFY_DURATION_MAX</a>,</div><div class="line">                         <span class="keyword">true</span>); <span class="comment">// run from the beginning of verification</span></div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">// Run Option 2: Run verification for a specific time before returning.</span></div><div class="line">    result = <a class="code" href="group___diagnostic.html#ga13fefc769f8582db50a71b4542b92371">RAIL_Verify</a>(railHandle,</div><div class="line">                         &amp;configVerify,</div><div class="line">                         100,   <span class="comment">// run for 100 microseconds before returning</span></div><div class="line">                         <span class="keyword">true</span>); <span class="comment">// run from the beginning of verification</span></div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a4bea7d8dd1a2b6a8b849cef8336ffc88">RAIL_STATUS_SUSPENDED</a> == result) {</div><div class="line">      responsePrint(<span class="stringliteral">&quot;verifyRadio&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;verification suspended - run again to continue&quot;</span>);</div><div class="line">      result = <a class="code" href="group___diagnostic.html#ga13fefc769f8582db50a71b4542b92371">RAIL_Verify</a>(railHandle,</div><div class="line">                           &amp;configVerify,</div><div class="line">                           100,    <span class="comment">// run for 100us before returning</span></div><div class="line">                           <span class="keyword">false</span>); <span class="comment">// run from where verification left off</span></div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">switch</span> (result) {</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a9d08f2cf4b5a12507982c72d5b896a02">RAIL_STATUS_NO_ERROR</a>:</div><div class="line">    {</div><div class="line">      responsePrint(<span class="stringliteral">&quot;verifyRadio&quot;</span>, <span class="stringliteral">&quot;success, done&quot;</span>);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a57e7dc36f3bfaceb0dff3a8104b3cb63">RAIL_STATUS_INVALID_PARAMETER</a>:</div><div class="line">    {</div><div class="line">      responsePrint(<span class="stringliteral">&quot;verifyRadio&quot;</span>, <span class="stringliteral">&quot;invalid input parameter&quot;</span>);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a3ddab27ab553255df061547afe90ebee">RAIL_STATUS_INVALID_STATE</a>:</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">    {</div><div class="line">      responsePrint(<span class="stringliteral">&quot;verifyRadio&quot;</span>, <span class="stringliteral">&quot;data corruption&quot;</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 25 2019 15:16:57 for RAIL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
