// File: host-main.c
//
// Description: Main entry point for Unix Host application.
//
// Copyright 2014 by Silicon Laboratories. All rights reserved.             *80*
//----------------------------------------------------------------
// This app requires argument, the USB tty driver
// -u <USB tty driver>
//
// For example:
// sudo build/host-app -u /dev/ttyUSB0
//
// Add the --verbose argument to view all TX'd and RX'd ASHv3 frames

#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include "stack/include/ember.h"

#include <stdlib.h>
#include <termios.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <net/if.h>
#include <signal.h>

#ifdef __linux__
  #include <linux/if_tun.h>
#endif

#include "stack/framework/event-queue.h"
#include "flex-bookkeeping.h"
#include "csp/callbacks-frame-utilities.h"
#include "host-ncp/binary-management.h"
#include "host-ncp/ash-v3-test.h"
#include "host-ncp/host-buffer-management.h"
#include "uart-link-protocol.h"
#include "host-stream.h"
#include "host-driver.h"
#include "csp/csp-enum.h"
#include "hal/micro/generic/ash-v3.h"
#include "host-ncp/serial-link-host.h"
#include "flex-callbacks.h"
#include "serial-bootloader/bootload-ncp.h"

#ifdef UNIX_HOST
  #define EMBER_READ   read
  #define EMBER_WRITE  write
  #define EMBER_SELECT select
  #define LOG(x) x
#else
  #error "Only unix Host supported for now."
#endif

int ncpFileDescriptor = 1;
bool postAshUpWorkDone = false; // ensure the init commands are sent once ash is up
ShutDownState shutDownState = SHUTDOWN_NOT_REQUESTED;

// Our entry point is typically main(), except in simulation.
// In simulation we don't include the cortexm3-specific headers.
#if defined(EMBER_TEST)
  #define MAIN nodeMain
  #if defined(EMBER_AF_API_DIAGNOSTIC_CORTEXM3)
    #undef EMBER_AF_API_DIAGNOSTIC_CORTEXM3
  #endif // EMBER_AF_API_DIAGNOSTIC_CORTEXM3
#else
  #define MAIN main
#endif // EMBER_TEST

#ifdef EMBER_AF_API_SERIAL
  #include EMBER_AF_API_SERIAL
// TODO: SERIAL_INIT() should be auto-generated by AppBuilder
  #define SERIAL_INIT()                                                                                \
  do {                                                                                                 \
    emberSerialInit((uint8_t)APP_SERIAL, (SerialBaudRate)APP_BAUD_RATE, (SerialParity)PARITY_NONE, 1); \
  } while (FALSE)
#else
  #define SERIAL_INIT()
  #define emberSerialPrintfLine(...)
#endif

// If printing is enabled, we will print some diagnostic information about the
// most recent reset and also during runtime.  On some platforms, extended
// diagnostic information is available.
#if defined(EMBER_AF_API_SERIAL) && defined(EMBER_AF_PRINT_ENABLE)
  #if defined(EMBER_AF_API_DIAGNOSTIC_CORTEXM3)
    #include EMBER_AF_API_DIAGNOSTIC_CORTEXM3
  #endif
static void printResetInformation(void);
  #define PRINT_RESET_INFORMATION printResetInformation
  #define emberAfGuaranteedPrint(...) \
  emberSerialGuaranteedPrintf(APP_SERIAL, __VA_ARGS__)
  #define emberAfGuaranteedPrintln(...)                   \
  do {                                                    \
    emberSerialGuaranteedPrintf(APP_SERIAL, __VA_ARGS__); \
    emberSerialGuaranteedPrintf(APP_SERIAL, "\r\n");      \
  } while (FALSE)
#else
  #define PRINT_RESET_INFORMATION()
  #define emberAfGuaranteedPrint(...)
  #define emberAfGuaranteedPrintln(...)
#endif

#define ARG_LENGTH 40
#define STRINGIFY(x) #x
#define STRINGIFYX(x) STRINGIFY(x)

typedef enum {
  NO_TEST,
  TEST_BOOTSTRAP,
} TestMode;

static TestMode testMode = NO_TEST;
static bool displayPrompt = false;
bool verbose = false;
bool logEnabled = false;
EventQueue emApiAppEventQueue;

// // Data messages from the IP stack are forwarded to the NCP.
void emNotifyTxComplete(void)
{
}

void quitCommand(void)
{
  exit(1);
}

static AshState wantedAshState = ASH_STATE_RESET_TX_PRE;

static void printSuccess(void)
{
  emberSerialPrintfLine(APP_SERIAL, "Success");
}

void txBufferFullHandler(const uint8_t *packet,
                         uint16_t packetLength,
                         uint16_t written)
{
  emberSerialPrintfLine(APP_SERIAL,
                        "warning: ASH's buffers are full. "
                        "tried to write %u bytes but was only able to write %u",
                        packetLength,
                        written);
}

void txFailedHandler(uint8_t fd,
                     const uint8_t *packet,
                     uint16_t packetLength,
                     uint16_t written)
{
  assert(false);
}

void emberAshStatusHandler(AshState state)
{
  assert(state < ASH_STATE_LAST);

  if (wantedAshState < ASH_STATE_LAST) {
    wantedAshState += 1;
  }

  if (state == ASH_STATE_RUNNING) {
    emberSerialPrintfLine(APP_SERIAL, "ASHv3 is up");

    if (!postAshUpWorkDone) {
      emberAfInit();
      emberAfMainInitCallback();
      postAshUpWorkDone = true;
    }

    if (testMode == TEST_BOOTSTRAP) {
      printSuccess();
      // we're done
      exit(1);
    }
  }
}

void resetAshCommand(void)
{
  wantedAshState = ASH_STATE_RESET_TX_PRE;
  uartLinkReset();
}

#ifndef EMBER_TEST
static void signalHandler(int signal)
{
  close(ncpFileDescriptor);
}

static void printUsage(void)
{
  printf("usage: ash-v3-test-app --uart uart_file "
         "[--test-bootstrap] [--verbose]\n\n"
         "--uart:           required, its value is the uart file\n"
         "--test-bootstrap: perform a bootstrap test\n");
}

void halHostSerialInit(int argc, char **argv)
{
  char uartArg[ARG_LENGTH + 1] = { 0 };
  bool ncpUsesSocket = false;
  bool uartSet = false;
  bool breakout = false;

  while (!breakout) {
    static struct option long_options[] = {
      { "uart", required_argument, 0, 'u' },
      { "test-bootstrap", no_argument, 0, 'b' },
      { "verbose", no_argument, 0, 'v' },
      { 0, 0, 0, 0 }
    };

    int option_index = 0;
    int c = getopt_long(argc, argv, "u:ve:b", long_options, &option_index);

    if (c == -1) {
      if (option_index != argc && option_index != 0) {
        fprintf(stderr, "Unexpected argument %s\n\n", argv[option_index]);
        printUsage();
        exit(1);
      }
    }

    switch (c) {
      case 0:
        break;
      case '?':
        printUsage();
        exit(1);
        break;
      case 'u':
        sscanf(optarg, "%" STRINGIFYX(ARG_LENGTH) "s", uartArg);
        uartSet = true;
        break;
      case 'b':
        testMode = TEST_BOOTSTRAP;
        break;
      case 'v':
        verbose = true;
        break;
      default:
        breakout = true;
        break;
    }
  }

  if (!uartSet) {
    printUsage();
    exit(1);
  }

  emOpenNcpUart(uartArg);

  // configure signal handlers
  struct sigaction sigHandler;
  sigHandler.sa_handler = signalHandler;
  sigemptyset(&sigHandler.sa_mask);
  sigHandler.sa_flags = 0;
  sigaction(SIGINT, &sigHandler, NULL);
  sigaction(SIGTERM, &sigHandler, NULL);
  sigaction(SIGABRT, &sigHandler, NULL);
}

void halHostSerialTick(void)
{
  fd_set input;
  FD_ZERO(&input);
  FD_SET(ncpFileDescriptor, &input);

  int maxFd = ncpFileDescriptor;

  struct timeval timeout;
  timeout.tv_sec = 0;
  timeout.tv_usec = 100000;

  int selectResult = select(maxFd + 1, &input, NULL, NULL, &timeout);
  assert(selectResult >= 0);

  if (selectResult > 0) {
    emCheckNcpUartInput(&input);
  }
}

void halHostUartLinkTx(const uint8_t *data, uint16_t length)
{
  if (EMBER_WRITE(ncpFileDescriptor, data, length) != length) {
    fprintf(stderr, "error: cannot write to the uart\n");
    exit(1);
  }

  emAshReallyNotifyTxComplete(false);
}

bool halHostUartTxIdle(void)
{
  return true;
}
#endif

//----------------------------------------------------------------
// Main

#ifdef UNIX_HOST
  #define RETURN_TYPE int
#else
  #define RETURN_TYPE void
  #define argc 0
  #define argv NULL
#endif

const char *emAppName = "host-app";
EmberTaskId emAppTask;
extern const EmberEventData emAppEvents[];

void emberMarkApplicationBuffers(void)
{
  markCallbacksBuffers();
}

static BufferMarker markers[] = {
  emberMarkApplicationBuffers,
  emberMarkApplicationBuffersHandler,
  NULL
};

RETURN_TYPE MAIN(MAIN_FUNCTION_PARAMETERS)
{
  halInit();
  INTERRUPTS_ON();
  SERIAL_INIT();

  PRINT_RESET_INFORMATION();

  emberTaskEnableIdling(true);

  emAppTask = emberTaskInit(emAppEvents);

  emInitializeEventQueue(&emApiAppEventQueue);
  emInitializeBuffers();

  initializeCallbacksBuffers();

#ifdef EMBER_TEST
  halHostSerialInit();
#else
  halHostSerialInit(argc, argv);
#endif

  ncpUartUseAsh = true;
  uartLinkReset();
  emberCommandReaderInit();

  const char *prompt = "host-app";

  if (testMode == TEST_BOOTSTRAP) {
    displayPrompt = false;
  }

  if (displayPrompt) {
    emberSerialPrintf(APP_SERIAL, "%s> ", prompt);
  }

  while (true) {
    halResetWatchdog();

    // This state processing is for serial bootloading
    switch (shutDownState) {
      case SHUTDOWN_NOT_REQUESTED:
        halHostSerialTick();
        break;
      case SHUTDOWN_REQUESTED:
        close(ncpFileDescriptor);
        shutDownState = SHUTDOWN_DONE;
        break;
      case SHUTDOWN_DONE:
        // do nothing
        // image should be bootloaded now
        // which will trigger a reset
        break;
      default:
        break;
    }

    emberRunEventQueue(&emApiAppEventQueue);
    emberRunEvents(emAppEvents);

    while (callbacksPending()) {
      processCallbacks();
    }
    #ifdef EMBER_TEST
    simulatedTimePasses();
    #endif

    emberAfMainTickCallback();
    emberAfTick();

    emberRunTask(emAppTask);
    emReclaimUnusedBuffers(markers);
  }

#ifdef UNIX_HOST
  return 0;
#endif
}

static void printResetInformation(void)
{
  // Information about the most recent reset is printed during startup to aid
  // in debugging.
  emberAfGuaranteedPrintln("Reset info: 0x%x (%p)",
                           halGetResetInfo(),
                           halGetResetString());

#if defined(EMBER_AF_API_DIAGNOSTIC_CORTEXM3)
  emberAfGuaranteedPrintln("Extended reset info: 0x%2x (%p)",
                           halGetExtendedResetInfo(),
                           halGetExtendedResetString());
  if (halResetWasCrash()) {
    halPrintCrashSummary(APP_SERIAL);
    halPrintCrashDetails(APP_SERIAL);
    halPrintCrashData(APP_SERIAL);
  }
#endif // EMBER_AF_API_DIAGNOSTIC_CORTEXM3
}

// stubs
void emApiEventDelayUpdatedFromIsrHandler(Event *event)
{
}

// stubs (this is referenced from the ashv3 code).
void emApiCounterHandler(EmberCounterType type, uint16_t increment)
{
}

void emberEchoReturn(uint8_t *data, uint8_t length)
{
  emberSerialPrintf(APP_SERIAL, "Echo return: {");
  uint8_t i;

  for (i = 0; i < length; i++) {
    emberSerialPrintf(APP_SERIAL, "%X ", data[i]);
  }

  emberSerialPrintfLine(APP_SERIAL, "}\n");
}

// The following command handlers were generated by vncp-update.sh
void emberStackStatusHandler(EmberStatus status)
{
  emberAfStackStatus(status);
  emberAfStackStatusCallback(status);
}

void emberChildJoinHandler(EmberNodeType nodeType,
                           EmberNodeId nodeId)
{
  emberAfChildJoinCallback(nodeType, nodeId);
  emberAfChildJoin(nodeType, nodeId);
}

void emberRadioNeedsCalibratingHandler(void)
{
  emberAfRadioNeedsCalibratingCallback();
  emberAfRadioNeedsCalibrating();
}

// no emberStackIsrHandler

bool emberStackIdleHandler(uint32_t *idleTimeMs)
{
  return false;
}

void emberMessageSentHandler(EmberStatus status, EmberOutgoingMessage *message)
{
  emberAfMessageSentCallback(status, message);
  emberAfMessageSent(status, message);
}

void emberIncomingMessageHandler(EmberIncomingMessage *message)
{
  emberAfIncomingMessageCallback(message);
  emberAfIncomingMessage(message);
}

void emberIncomingMacMessageHandler(EmberIncomingMacMessage *message)
{
  emberAfIncomingMacMessageCallback(message);
  emberAfIncomingMacMessage(message);
}

void emberMacMessageSentHandler(EmberStatus status,
                                EmberOutgoingMacMessage *message)
{
  emberAfMacMessageSentCallback(status, message);
  emberAfMacMessageSent(status, message);
}

void emberIncomingBeaconHandler(EmberPanId panId,
                                EmberNodeId nodeId,
                                int8_t rssi,
                                bool permitJoining,
                                uint8_t payloadLength,
                                uint8_t *payload)
{
  emberAfIncomingBeaconCallback(panId,
                                nodeId,
                                rssi,
                                permitJoining,
                                payloadLength,
                                payload);
  emberAfIncomingBeacon(panId,
                        nodeId,
                        rssi,
                        permitJoining,
                        payloadLength,
                        payload);
}

void emberIncomingBeaconExtendedHandler(EmberPanId panId,
                                        EmberMacAddress *source,
                                        int8_t rssi,
                                        bool permitJoining,
                                        uint8_t beaconFieldsLength,
                                        uint8_t *beaconFields,
                                        uint8_t beaconPayloadLength,
                                        uint8_t *beaconPayload)
{
  emberAfIncomingBeaconExtendedCallback(panId,
                                        source,
                                        rssi,
                                        permitJoining,
                                        beaconFieldsLength,
                                        beaconFields,
                                        beaconPayloadLength,
                                        beaconPayload);
  emberAfIncomingBeaconExtended(panId,
                                source,
                                rssi,
                                permitJoining,
                                beaconFieldsLength,
                                beaconFields,
                                beaconPayloadLength,
                                beaconPayload);
}

void emberActiveScanCompleteHandler(void)
{
  emberAfActiveScanCompleteCallback();
  emberAfActiveScanComplete();
}

void emberEnergyScanCompleteHandler(int8_t mean,
                                    int8_t min,
                                    int8_t max,
                                    uint16_t variance)
{
  emberAfEnergyScanCompleteCallback(mean, min, max, variance);
  emberAfEnergyScanComplete(mean, min, max, variance);
}

void emberFrequencyHoppingStartClientCompleteHandler(EmberStatus status)
{
  emberAfFrequencyHoppingStartClientCompleteCallback(status);
  emberAfFrequencyHoppingStartClientComplete(status);
}
